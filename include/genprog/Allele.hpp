/*\***********************************************************************\*//**
 * MODULE: Allele.hpp
 *
 * @author Dennis Drown
 * @date   16 Aug 2011
 *
 * @copyright 2011 Dennis Drown and Ostrich Ideas
 *//**********************************************************************\*///
#ifndef ALLELE_HPP
#define	ALLELE_HPP

#include <sstream>

#include "oi-string.hpp"
#include "genprog/genprog.hpp"

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#if ENABLE_CUDA
#include "FlatGene.hpp"
#endif


namespace oi { namespace genprog {

class Allele;
class AttrWindow;
class Context;
class FuncAllele;
class Splice;
class World;

typedef Allele* (*FactoryPtr)(const World& world);


/*/- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- **\*/
// ⣎⣱ ⡇ ⡇ ⢀⡀ ⡇ ⢀⡀
// ⠇⠸ ⠣ ⠣ ⠣⠭ ⠣ ⠣⠭
/*/- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- -=- *//**
 * A node in an individual's genetic program tree
 *
 * @note    Some member variables and functions refer to "nodes" instead of
 *          "alleles."  Basically a node is an allele.  We say "node" when
 *          we're dealing with tree structure manipulations, and "allele"
 *          when we're doing GP.
 *///-------------------------------------------------------------------------
class Allele
{
    friend class Splice;

public:
    /**
     * Indicators for derived Allele classes, mainly used when generating new
     * Alleles via newRandAllele and for GPGPU Allele-tree translations.
     *///--------------------------------------------------------------------
    enum Type               ///< Derived classes we know about and provide via newRandAllele
    {
        Const = 0,          ///< Indicates ConstAllele
        Func,               ///< Indicates FuncAllele
        Lookup,
        NumTypes            ///< Keep this last to count the number of kids we know about
    };


    /**
     * Token for attribute lookups in FlatDataAllele objects, signifying that
     * the allele's attribute is the target attribute.
     *
     * @note    This constant is currently needed only for GPGPU processing,
     *          and so we tie it to the value defined for the NVidia Cuda
     *          logic's FlatDataAllele::TARGET.  We define it in CPU-only
     *          builds to help limit the ENABLE_CUDA code.
     *///--------------------------------------------------------------------
#if ENABLE_CUDA
    static constexpr u_int TARGET = FlatDataAllele::TARGET;
#else
    static constexpr u_int TARGET = std::numeric_limits<u_int>::max();
#endif


    /**
     * Creates an empty Allele
     *
     * @param parent    Pointer to the parent node, if known
     *///--------------------------------------------------------------------
    Allele(Allele *parent = NULL);


    /**
     * Tear down the Allele!
     *///--------------------------------------------------------------------
    virtual ~Allele();


    /**
     * Factory function to generate a new Allele of any of the derived types
     * we know about.
     *
     * @note    Any object generated by this function must be deallocated when
     *          no longer needed with the normal C++ delete.
     *
     * @param   world   The problem space for which we are generating an allele
     *
     * @return  A newly allocated Allele object
     *///--------------------------------------------------------------------
    static Allele * newRandAllele(const World& world)
    {
        int ndx = lrand48() % NumTypes;

        return factoryLib_[ndx](world);
    }


    /**
     * Copy constructor, DISABLED!
     *///--------------------------------------------------------------------
    Allele(const Allele& allele) = delete;


    /**
     * Assignent operator, DISABLED!
     *///--------------------------------------------------------------------
    Allele & operator=(const Allele& rhs) = delete;


    /**
     * Returns true if the Allele directly references data for the dependent
     * (target) attribute of the model.
     *
     * @note    This method should return false for all allele objects except
     *          for LookupAlleles.
     *
     * @return  true,  if the Allele touches the target attribute;
     *          false, otherwise
     *///--------------------------------------------------------------------
    virtual bool isTarget() const noexcept
    {
        return false;
    }


#if ENABLE_CUDA
    /**
     * Gets the Allele code associated with the (derived) Allele object.
     *
     * @return  The enum code for the (child) Allele type
     *///--------------------------------------------------------------------
    virtual Type getType() const noexcept = 0;


    /**
     * Returns true if this Allele object represents a GenProg function. In
     * other words, the Allele is a FuncAllele.
     *
     * @return  true if this is 
     *///--------------------------------------------------------------------
    bool isFunc() const noexcept
    {
        const Type type  = getType();
        const bool yesNo = (Allele::Func == type);

        // Make sure future development hasn't made new kinds of Function Alleles
        assert(yesNo
            || (Allele::Const  == type)
            || (Allele::Lookup == type));

        return yesNo;
    }


    /**
     * Returns true if this Allele object represents GenProg function data.
     * In other words, the Allele is a ConstAllele or a LookupAllele.
     *
     * @return  true if this is 
     *///--------------------------------------------------------------------
    bool isData() const noexcept
    {
        const Type type  = getType();
        const bool yesNo = (Allele::Func != type);

        // Make sure future development hasn't made new kinds of Alleles
        assert(!yesNo                           // It *is* a FuncAllele
            || (Allele::Const   == type)
            || (Allele::Lookup  == type));

        return yesNo;
    }


    /**
     * Returns the value of the allele
     *
     * @param win       Attribute window
     * @param flatGend  GPGPU (cuda) chromosome representation
     *
     * @return      The allele's real number value
     *///--------------------------------------------------------------------
    virtual Real getValue(const AttrWindow& win, FlatGene& flatGene) const = 0;
#endif


    /**
     * Returns the value of the constant allele
     *
     * @param win   Attribute window (unused in ConstAlleles)
     *
     * @return      The allele's real number value
     *///--------------------------------------------------------------------
    virtual Real getValue(const AttrWindow& win) const = 0;


    /**
     * String representation of the Allele
     *
     * @return      The node count for this Allele
     *///--------------------------------------------------------------------
    virtual const std::string toString() const
    {
        std::stringstream ss;

        ss << "ALLELE#" << nodeCnt_ << "#0x" << std::hex << this << "#";
        return ss.str();
    }


    /**
     * Returns the newly allocated copy of this Allele. The returned object
     * must be deleted by the caller once it is no longer needed.
     *
     * @return      A new copy of this Allele
     *///--------------------------------------------------------------------
    virtual Allele *newCopy() const = 0;


    /**
     * Returns the sum of all the nodes in this Allele.
     *
     * @note    This method is meant for debugging. @ref getNodeCount() is the
     *          preferred method for obtaining the node sum.
     *
     * @return  The count of nodes in this Allele and all sub-alleles.
     *///--------------------------------------------------------------------
    virtual u_int __calcNodeCount() const
    {
        return 1;
    }

    /**
     *
     * Returns the count of this node, and all nodes below it
     *
     * @return      The node count for this Allele
     *///--------------------------------------------------------------------
    u_int getNodeCnt() const
    {
        return nodeCnt_;
    }


    /**
     * RSets the node that is this Allele's parent
     *
     * @return      The node count for this Allele
     *///--------------------------------------------------------------------
    void setParent(Allele *parent)
    {
        parent_ = parent;
    }


protected:
    u_int       nodeCnt_;       ///< Count of this node and all nodes (Alleles) under it
    Allele     *parent_;        ///< Pointer to node (@ref Allele) directly above in tree
                                ///<   will be NULL for top level gene

private:
    static const FactoryPtr factoryLib_[];
};


} } // ns{ oi::genprog }

#endif	/* ALLELE_HPP */
